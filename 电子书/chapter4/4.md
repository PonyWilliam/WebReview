# js常考点
## 变量类型和计算
### 1. typeof能判断哪些类型  
#### 功能：
1. 识别所有值类型
2. 识别函数
3. 判断是否是引用类型（不可再细分）
#### 能做什么？
1. 判断所有值类型
2. 判断函数
3. 能识别引用类型（不能再继续识别）
### 2. 何时使用 === 何时使用 ==  
truly变量：!!a === true  
falsly 变量: !!a === false  
==  会进行类型转换，如'1'==1 -> true 而 === 不会  
### 3. 值类型和引用类型的区别  
#### 知识点：
1. 值类型：String（字符串）、Number（数值）、boolean（布尔值）、Undefined
2. 引用类型：Array（数组）、Object（对象）、Function（函数）、Null  
#### 区别：
1. 存储位置不一样  
    1. 值类型的存储存储在内存中。如果在函数内声明一个变量，那么函数执行完毕则会回收
    2. 引用类型的变量名也会保存在栈内存中，但是变量值会存储在堆内存中
2. 复制方式不一样
    1. 值类型的赋值就是深复制，会开辟新的内存空间用于存储
    2. 引用类型的变量复制只是传递引用，浅复制，相当于将指针指向地址传给了他而已  
3. 值类型无法添加属性和方法、而引用类型可以添加。
4. 值类型的==在比较时会做类型转换、而===要求值和类型必须都一致。  
5. 引用类型的比较是引用地址的比较。等于判断会比较对象内存地址。所以只要不是同一个变量基本上都为false
#### 为什么要这么做？
因为引用类型下面可以存储json等等，可能会直接导致栈溢出不好管理，因此将它存储到堆内方便管理。  
#### tips
1. 使用const定义常量必须赋值，否则会报错。
2. null是一个特殊的引用类型，指向空地址。
3. 函数是一个特殊的引用类型，不用于存储数据，所以没有拷贝、复制函数一说。
#### 扩展：深拷贝如何实现

### 4. 手写深拷贝
```js
function DeepClone(obj = {}){
    if (typeof obj !== 'object' || obj == null) {
        return obj
    }
    let result
    if(obj instanceof Array){
        result = []
    }else{
        result = {}
    }
    for(let key in obj){
        //确认不是proto
        if (obj.hasOwnProperty(key)){
            //递归
            result[key] = DeepClone(obj[key])
        }
    }
    return result
}
```